// =========================================
// TSPP++ Ultimate Test Code (Grammar Max)
// =========================================

// ---------- Imports ----------
import Math from "std"; // exercise Import

// ---------- Type Aliases (Union & Intersection) ----------
typedef Meter = float;
typedef ID = int;
typedef MaybeNum = int | float;            // Union
typedef StringOrInt = string | int;        // Union
typedef PointLike = IPoint & Printer;      // Intersection (structural)

// ---------- Interfaces ----------
interface IPoint {
  x: float;
  y: float;
  toString(): string;
  move(dx: float, dy: float): void;
}

interface Box<T> {
  value: T;
  get(): T;
  set(v: T): void;
}

interface Printer {
  print(): void;
}

// ---------- Classes demonstrating fields, modifiers, constructor, static block ----------
class Point implements IPoint {
  public let x: float;
  public let y: float;

  // Field modifiers coverage
  #static let createdCount: int = 0;     // class counter
  #readonly let tag: string = "P";       // readonly field (doesn’t change)
  #volatile let vflag: int = 0;          // parse surface
  #atomic let alock: int = 0;            // parse surface

  static {
    console.log("Point.static block"); // Expected: Point.static block
  }

  constructor(x: float, y: float) {
    this.x = x;
    this.y = y;
    Point.createdCount = Point.createdCount + 1;
  }

  #static function stats(): string {
    return "Point.count=" + Point.createdCount;
  }

  function toString(): string {
    return "(" + this.x + ", " + this.y + ")";
  }

  public function move(dx: float, dy: float): void {
    this.x = this.x + dx;
    this.y = this.y + dy;
  }
}

// Packed / Pinned classes + array field + getters/setters
#packed class ByteArray {
  public let data: int[];

  constructor(n: int) {
    this.data = new int[n];
  }

  function set(i: int, v: int): void {
    this.data[i] = v; // IndexAccess assignment
  }

  function get(i: int): int {
    return this.data[i];
  }
}

#pinned class ResourceHandle implements Printer {
  public let id: int;

  constructor(id: int) { this.id = id; }

  function print(): void {
    console.log("Resource#" + this.id); // Expected: Resource#7
  }
}

// Base → Derived + implements + access modifiers + override method modifier
class Animal {
  protected let name: string;

  #static let kingdomName: string = "Animalia";

  constructor(name: string) { this.name = name; }

  function speak(): string { return this.name + " makes a sound"; }

  #static function kingdom(): string { return Animal.kingdomName; }
}

class Dog extends Animal implements Printer {
  private let breed: string;

  constructor(name: string, breed: string) {
    super(name);
    this.breed = breed;
  }

  public #override function speak(): string {
    return this.name + " barks (" + this.breed + ")";
  }

  function getBreed(): string { return this.breed; }

  public function print(): void { console.log(this.speak()); /* Expected: Rex barks (Labrador) */ }
}

// Abstract + Final with override
#abstract class Shape {
  function area(): float;
}

#final class Circle extends Shape {
  private let r: float;

  constructor(r: float) { this.r = r; }

  public #override function area(): float {
    return 3.14 * this.r * this.r;
  }
}

// ---------- Generic class implementing generic interface ----------
class SBox<T> implements Box<T> {
  public let value: T;

  constructor(v: T) { this.value = v; }
  function get(): T { return this.value; }
  function set(v: T): void { this.value = v; }
}

// ---------- Function Declarations (with FunctionModifiers) ----------
// Note: keep modifiers light; many engines parse them but ignore semantics.
#constexpr function firstOf<T>(a: T, b: T): T { return a; } // generics + modifier surface
#inline function idNum(n: MaybeNum): MaybeNum { return n; } // union type in params/ret

function stringifyPoint(pt: IPoint): string {
  return "Point" + pt.toString();
}

function useBoxString(bx: Box<string>): string {
  bx.set(bx.get() + "!");
  return bx.get();
}

// ---------- Statements & Expressions & Precedence ----------
function isEven(n: int): bool {
  // Uses %, ==, return
  return (n % 2) == 0;
}

function sumTo(n: int): int {
  // while loop + assignment
  let s: int = 0;
  let i: int = 1;
  while (i <= n) {
    s = s + i;
    i = i + 1;
  }
  return s;
}

function forVariants(): int {
  let total: int = 0;

  // (1) VariableDecl ForInit
  for (let i: int = 0; i < 3; i = i + 1) {
    total = total + i; // 0+1+2 = 3
  }

  // (2) Expression ForInit
  let j: int = 0;
  for (j = 0; j < 2; j = j + 1) {
    total = total + 10; // +20
  }

  // (3) Empty ForInit
  let k: int = 0;
  for (; k < 2; k = k + 1) {
    total = total + 100; // +200
  }

  return total; // 223
}

function precedenceDemo(): int {
  // Multiplicative → Additive → Shift → Bitwise → Equality → Logical
  let a: int = 5; // 0101
  let b: int = 3; // 0011

  let mul: int = 2 * 3;           // 6
  let add: int = mul + 4;         // 10
  let addMul: int = 2 + 3 * 4;    // 14
  let shiftL: int = (1 + 1) << 3; // 16
  let band: int = a & b;          // 1
  let bor: int = a | b;           // 7
  let bxor: int = a ^ b;          // 6
  let not0: int = ~0;             // -1
  let neq: bool = (addMul != 13); // true
  let ge: bool = (shiftL >= 16);  // true
  let logic: bool = (neq && ge) || false; // true

  // emulate ternary via if (no ?: in grammar)
  let bonus: int = 0;
  if (logic) { bonus = 1; }

  return addMul + shiftL + band + bor + bxor + not0 + bonus; // 14+16+1+7+6-1+1 = 44
}

function memberAndIndexAccess(): int {
  let p: Point = new Point(1.0, 2.0);
  p.move(1.0, 3.0); // (2.0, 5.0)

  let arr: int[] = [10, 20, 30];
  arr[1] = arr[1] + 79; // 99

  let chk: int = arr[0] + arr[1] + arr[2]; // 139
  return chk + 2 + 5; // + p.x + p.y = 146
}

// ---------- Pointer & Smart-Pointer (surface typing) ----------
function pointerPlay(): int {
  // PointerType with address-space qualifiers
  let pi: @unsafe int* = null;
  let pf: @aligned float* = null;

  // SmartPointerType
  let sp1: #unique<Point> = null;
  let sp2: #shared<string> = null;
  let sp3: #weak<Circle> = null;

  let ok: int = 0;
  if (pi == null && pf == null) { ok = ok + 1; }
  if (sp1 == null && sp2 == null && sp3 == null) { ok = ok + 1; }
  return ok; // 2
}

// ---------- Intersection Type adapter so PointLike can be exercised ----------
class PAdapter implements IPoint, Printer {
  public let x: float;
  public let y: float;

  constructor(x: float, y: float) { this.x = x; this.y = y; }

  function toString(): string { return "(" + this.x + ", " + this.y + ")"; }
  function move(dx: float, dy: float): void { this.x = this.x + dx; this.y = this.y + dy; }
  function print(): void { console.log("Adapter:" + this.toString()); /* Expected: Adapter:(2,3) */ }
}

function describePointLike(p: PointLike): string {
  p.print();
  return "Desc=" + p.toString();
}

// ---------- VarModifiers (#heap/#stack/#static) on variables ----------
function storagePlay(): int {
  #heap let hx: int = 10;
  #stack const sy: int = 32;
  // #static var is already covered as field; here we keep locals simple
  return hx + sy; // 42
}

// ---------- Main (exercise everything) ----------
function main(): int {
  // Basic types & typedefs
  let dist: Meter = 3.5;
  let ident: ID = 42;
  let flexible: StringOrInt = "ok";

  console.log("dist: ", dist);                      // Expected: 3.5
  console.log("ident: ", ident);                    // Expected: 42
  console.log("flexible: ", flexible);              // Expected: ok

  // Classes & interfaces
  let p1: Point = new Point(1.5, 2.5);
  console.log("p1: ", p1.toString());               // Expected: (1.5, 2.5)
  p1.move(0.5, 0.5);
  console.log("p1 moved: ", p1.toString());         // Expected: (2, 3)
  console.log(Point.stats());                        // Expected: Point.count=1

  console.log("stringifyPoint(p1): ", stringifyPoint(p1)); // Expected: Point(2, 3)

  let sb: SBox<string> = new SBox<string>("hi");
  console.log("useBoxString(sb): ", useBoxString(sb));      // Expected: hi!

  // Inheritance + static methods
  let a: Animal = new Animal("Generic");
  console.log("a.speak(): ", a.speak());            // Expected: Generic makes a sound
  console.log("Animal.kingdom(): ", Animal.kingdom()); // Expected: Animalia

  let d: Dog = new Dog("Rex", "Labrador");
  console.log("d.speak(): ", d.speak());            // Expected: Rex barks (Labrador)
  console.log("d.getBreed(): ", d.getBreed());      // Expected: Labrador
  d.print();                                         // Expected: Rex barks (Labrador)

  // Abstract/Final
  let c: Circle = new Circle(2.0);
  console.log("c.area(): ", c.area());              // Expected: 12.56

  // Packed / Pinned
  let ba: ByteArray = new ByteArray(3);
  ba.set(0, 42);
  console.log("ba.get(0): ", ba.get(0));            // Expected: 42
  let rh: ResourceHandle = new ResourceHandle(7);
  rh.print();                                        // Expected: Resource#7

  // Generics (function + class)
  console.log("firstOf<int>(10,20): ", firstOf<int>(10, 20)); // Expected: 10
  let bxS: SBox<string> = new SBox<string>("A");
  let bxI: SBox<int> = new SBox<int>(5);
  console.log("bxS.get(): ", bxS.get());            // Expected: A
  console.log("bxI.get(): ", bxI.get());            // Expected: 5

  // Intersection + adapter
  let pl: PointLike = new PAdapter(2.0, 3.0);
  console.log(describePointLike(pl));               // Expected two lines:
                                                    // Adapter:(2,3)
                                                    // Desc=(2,3)

  // Statements & expressions
  let n: int = 6;
  console.log("isEven(6): ", isEven(n));            // Expected: true
  console.log("sumTo(5): ", sumTo(5));              // Expected: 15
  console.log("forVariants(): ", forVariants());    // Expected: 223
  console.log("precedenceDemo(): ", precedenceDemo()); // Expected: 44
  console.log("memberAndIndexAccess(): ", memberAndIndexAccess()); // Expected: 146

  // Assignment associativity demo
  let x: int = 0;
  let y: int = 0;
  x = y = 5;
  console.log("x: ", x);                            // Expected: 5
  console.log("y: ", y);                            // Expected: 5

  // Logical / shifts / bitwise-not
  let L: bool = (false && (1/0 == 0)) || true;
  console.log("logical: ", L);                      // Expected: true
  console.log("1<<3: ", 1 << 3);                    // Expected: 8
  console.log("8>>1: ", 8 >> 1);                    // Expected: 4
  console.log("~0: ", ~0);                          // Expected: -1

  // Pointers & smart pointers (surface)
  console.log("pointerPlay(): ", pointerPlay());    // Expected: 2

  // VarModifiers (#heap/#stack) on locals
  console.log("storagePlay(): ", storagePlay());    // Expected: 42

  // Return without expression (grammar allows); do nothing further.
  return 0;
}
