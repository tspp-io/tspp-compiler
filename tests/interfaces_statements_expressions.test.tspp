// ================================
// Interfaces + Statements + Expressions Coverage
// ================================

// ---------- Type Aliases ----------
typedef Meter = float;
typedef ID = int;
typedef StringOrInt = string | int;

// ---------- Interfaces ----------
interface IPoint {
  x: float;
  y: float;
  toString(): string;
  move(dx: float, dy: float): void;
}

interface Box<T> {
  value: T;
  get(): T;
  set(v: T): void;
}

// ---------- Classes to Implement Interfaces ----------
class Point implements IPoint {
  public let x: float;
  public let y: float;

  constructor(x: float, y: float) {
    this.x = x;
    this.y = y;
  }

  function toString(): string {
    return "(" + this.x + ", " + this.y + ")";
  }

  function move(dx: float, dy: float): void {
    this.x = this.x + dx;
    this.y = this.y + dy;
  }
}

class SBox<T> implements Box<T> {
  public let value: T;

  constructor(v: T) {
    this.value = v;
  }

  function get(): T {
    return this.value;
  }

  function set(v: T): void {
    this.value = v;
  }
}

// ---------- Statement & Expression Helpers ----------
function isEven(n: int): bool {
  // Uses ReturnStatement and Equality
  return (n % 2) == 0;
}

function sumTo(n: int): int {
  // While loop + Assignment + Additive
  let s: int = 0;
  let i: int = 1;
  while (i <= n) {
    s = s + i;
    i = i + 1;
  }
  return s;
}

function forVariants(): int {
  // Covers ForStatement with:
  //  (1) VariableDecl init
  //  (2) Expression init
  //  (3) Empty init
  let total: int = 0;

  // (1) VariableDecl ForInit
  for (let i: int = 0; i < 3; i = i + 1) {
    total = total + i; // adds 0+1+2 = 3
  }

  // (2) Expression ForInit
  let j: int = 0;
  for (j = 0; j < 2; j = j + 1) {
    total = total + 10; // adds 20
  }

  // (3) Empty ForInit
  let k: int = 0;
  for (; k < 2; k = k + 1) {
    total = total + 100; // adds 200
  }

  return total; // 3 + 20 + 200 = 223
}

function precedenceDemo(): int {
  // Covers precedence: Multiplicative, Additive, Shift, Bitwise, Equality, Logical
  let a: int = 5;   // 0101
  let b: int = 3;   // 0011

  let addMul: int = 2 + 3 * 4;          // 2 + 12 = 14
  let shiftMix: int = (1 + 1) << 3;     // 2 << 3 = 16
  let band: int = a & b;                 // 0101 & 0011 = 0001 -> 1
  let bor: int = a | b;                  // 0101 | 0011 = 0111 -> 7
  let bxor: int = a ^ b;                 // 0101 ^ 0011 = 0110 -> 6
  let not0: int = ~0;                    // bitwise not of 0 -> -1 (two's complement)
  let eq: bool = (addMul == 14);         // true
  let rel: bool = (shiftMix >= 16);      // true
  let logic: bool = (eq && rel) || false;// (true && true) || false -> true

  // Fold into a single int to verify quickly:
  //  addMul(14) + shiftMix(16) + band(1) + bor(7) + bxor(6) + not0(-1) + (logic? 1:0)
  let sum: int = addMul + shiftMix + band + bor + bxor + not0 + (logic ? 1 : 0);
  return sum; // 14 + 16 + 1 + 7 + 6 - 1 + 1 = 44
}

function memberAndIndexAccess(): int {
  // MemberAccess + IndexAccess + Assignment
  let p: Point = new Point(1.0, 2.0);
  p.move(1.0, 3.0); // p = (2.0, 5.0)

  // IndexAccess with a simple int array
  let arr: int[] = [10, 20, 30];
  arr[1] = arr[1] + 79; // 20 -> 99

  // Use some values to produce a stable checksum
  let chk: int = (arr[0] + arr[1] + arr[2]) + (p.x as int) + (p.y as int);
  return chk; // (10 + 99 + 30) + 2 + 5 = 146
}

// ---------- Interface-Typed Functions ----------
function stringifyPoint(pt: IPoint): string {
  // Uses MethodSignature call + MemberAccess
  return "Point" + pt.toString();
}

function useBoxString(bx: Box<string>): string {
  bx.set(bx.get() + "!");
  return bx.get();
}

// ---------- Main: exercise everything ----------
function main(): int {
  // TypeAlias usage
  let dist: Meter = 3.5;
  let ident: ID = 42;
  let flexible: StringOrInt = "ok";

  console.log("dist: ", dist);             // dist: 3.5
  console.log("ident: ", ident);           // ident: 42
  console.log("flexible: ", flexible);     // flexible: ok

  // Interfaces via classes + NewExpr
  let p1: Point = new Point(1.5, 2.5);
  console.log("p1: ", p1.toString());      // p1: (1.5, 2.5)
  p1.move(0.5, 0.5);
  console.log("p1 moved: ", p1.toString()); // p1 moved: (2, 3)

  // Interface-typed function usage
  console.log("stringifyPoint(p1): ", stringifyPoint(p1)); // stringifyPoint(p1): Point(2, 3)

  // Generic interface with Box<T>
  let sb: SBox<string> = new SBox<string>("hi");
  console.log("useBoxString(sb): ", useBoxString(sb)); // useBoxString(sb): hi!

  // Statements: if / else
  let n: int = 6;
  if (isEven(n)) {
    console.log("isEven(6): ", true);     // isEven(6): true
  } else {
    console.log("isEven(6): ", false);
  }

  // While + Return
  console.log("sumTo(5): ", sumTo(5));    // sumTo(5): 15

  // For variants
  console.log("forVariants(): ", forVariants()); // forVariants(): 223

  // Expression & operator precedence pack
  console.log("precedenceDemo(): ", precedenceDemo()); // precedenceDemo(): 44

  // Member & Index access
  console.log("memberAndIndexAccess(): ", memberAndIndexAccess()); // memberAndIndexAccess(): 146

  // Assignment associativity (right-assoc)
  let x: int = 0;
  let y: int = 0;
  x = y = 5;
  console.log("x: ", x); // x: 5
  console.log("y: ", y); // y: 5

  // Logical short-circuit demo
  let L: bool = (false && (1/0 == 0)) || true;
  console.log("logical: ", L); // logical: true

  // Bit shifts
  console.log("1<<3: ", 1 << 3); // 1<<3: 8
  console.log("8>>1: ", 8 >> 1); // 8>>1: 4

  // Bitwise NOT of 0
  console.log("~0: ", ~0); // ~0: -1

  return 0;
}
